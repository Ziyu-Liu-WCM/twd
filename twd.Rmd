---
title: "tweedieverse"
author: "Ziyu Liu"
date: "2024-03-20"
output: html_document
---

```{r warning=FALSE, message=FALSE}
library(SummarizedExperiment)
library(airway)
library(DESeq2)
library(edgeR)
library(ComplexHeatmap)
library(ggplot2)
library(EDASeq)
library(topGO)
library(tidyverse)
library(clusterProfiler)
library(gsEasy)
library(GOfuncR)
library(cplm)
library(BiocParallel)
library(parallel)
```



```{r}


data(airway)


## trt <- ifelse(airway$dex == "untrt", 0 , 1)

filter <- filterByExpr(airway)
table(filter)
filtered <- airway[filter, ]
df <- assay(filtered)





X <- airway$dex

tp_formula <- paste0("tmp_y", "~",
                             paste0( X, collapse = "+")) %>% as.formula()



registered()


```

```{r}
CPLM <- function(input, X, assay_name = "counts", n_threads = 1, BPPARAM = NULL, 
                  verbose = FALSE){
  


if (is.null(BPPARAM)) {
   BPPARAM <- if (.Platform$OS.type=="windows") {
    SnowParam(workers = n_threads)
     } else {
     MulticoreParam(workers = n_threads)
       }
}

input <- airway
WX
df <- assay(airway[filterByExpr(input), ])

## define per feature function
FUN <- function(i, WX){
tmp_y <- as.numeric(df[i, ])

fit.df <- data.frame(WX, tmp_y)

fit <- cpglm(formula = tmp_y ~ WX, 
                     link="log",
                     data = fit.df)
cplm_out <- capture.output(cplm_summary <- cplm::summary(fit)$coefficients)

res_i <- c(
        coe = unname(cplm_summary[,1][2]),
        std = unname(cplm_summary[,2][2]),
        pval = unname(cplm_summary[,4][2])
)
return(res_i)
}

FUN(1, X)

WX <- X
## run for loop

class(ix)


ix <- seq_len(nrow(df))

runtime <- system.time({
  out_tp <- bplapply(ix, FUN , wX = wX,  BPPARAM = BPPARAM)
  })

out_tp <- bplapply(ix, FUN , WX = WX)


mat_tp <- data.frame(do.call("rbind", out_tp))
rownames(mat_tp) <- rownames(df)
 
mat_tp$padj <- p.adjust(mat_tp$pval, method = "BH")

return(mat_tp)
return(runtime)
}

CPLM(airway, trt)
```


```{r pressure, echo=FALSE}
Tweediexp <- function(
    input,
    spatial_coords = NULL,
    X = NULL,
    family = poisson(),
    offset = log(input$sizeFactor),
    weights = NULL,
    assay_name = "counts",
    n_threads = 1,
    BPPARAM = NULL,
    verbose = FALSE,
    ...
) {


  # NOTE: Some code blocks are borrowed from nnSVG by Lukas M Weber.
  if (is(input, "SummarizedExperiment")) {
    spe <- input
    stopifnot("Can't find assay in spe" = assay_name %in% assayNames(spe))
  }

  if (!is.null(X)) {
    stopifnot(nrow(X) == ncol(input))
  }

  if (is.null(BPPARAM)) {
    BPPARAM <- MulticoreParam(workers = n_threads)
  }


  if (is(input, "SpatialExperiment")) {
    y <- assays(spe)[[assay_name]]
    coords <- spatialCoords(spe)
  } else {
    y <- input
    coords <- spatial_coords
    row_names <- rownames(input)
  }


  # Check family
  # NOTE: the code is copied from "stats::glm"
  if (is.character(family))
    family <- get(family, mode = "function", envir = parent.frame())
  if (is.function(family))
    family <- family()
  if (is.null(family$family)) {
    stop("'family' not recognized")
  }
  # Copy end
  if (!(family$family %in% c("gaussian", "negative binomial", "poisson"))){
    stop(
      "'family' has to be one of the following distributions: gaussian,",
      "negative binomial (negbin), poisson"
    )
  }
  # New function ends


  
  
  
   cplm::cpglm(
          formula = formula,
          data = data,
          link = link,
          optimizer = optimizer,
          na.action = na.action
        )
  
  
  

  flag_count_mdl <- family$family %in% c("negative binomial", "poisson")

  if (is.null(offset))
    offset <- rep(0, ncol(y))
  if (is.null(weights))
    weights <- rep(1, ncol(y))

  if(flag_count_mdl){
    if (is.null(offset)){
      warning("Using count-based model without providing offset.",
              "Library size is calculated with column sums of the count matrix")
      offset <- log(colSums2(y))
    }
  }



  stopifnot(ncol(coords)==2)
  colnames(coords) <- c("coord_x", "coord_y")


  if(!is.null(ncol(X)))
    stop("not implemented for complex desgin matrix.")
  if(is.null(ncol(X)))
    fit.df <- data.frame( coords)
  else {
    fit.df <- data.frame(
      coords,
      X
    )
  }


  ix <- seq_len(nrow(y))
  out_tp <- bplapply(ix, function(i) {
    # fit model (intercept-only model if x is NULL)
    fit.df$tmp_y <- y[i, ]
    runtime <- system.time({
      tp_formula <- "tmp_y~s(coord_x, coord_y, bs='tp')"
      if(!is.null(X)){
        tp_formula <- paste0(tp_formula, " + ",
                             paste0( "X", collapse = "+")
        )
      }

      tp_mdl <- gam(
        formula = tp_formula|> as.formula() ,
        family = family, data = fit.df,
        offset = offset, weights = weights)
    })

    if(flag_count_mdl) {
      res_i <- c(
        test_stat = anova(tp_mdl)$s.table[,"Chi.sq"],
        raw_p = anova(tp_mdl)$s.table[,"p-value"],
        runtime = runtime[["elapsed"]]
      )
    } else{
      res_i <- c(
        test_stat = anova(tp_mdl)$s.table[,"F"],
        raw_p = anova(tp_mdl)$s.table[,"p-value"],
        runtime = runtime[["elapsed"]]
      )
    }



    res_i
  }, BPPARAM = BPPARAM)

  # collapse output list into matrix
  mat_tp <- do.call("rbind", out_tp)

  if (is(input, "SpatialExperiment")) {
    # return in rowData of spe object
    stopifnot(nrow(spe) == nrow(mat_tp))
    rowData(spe) <- cbind(rowData(spe), mat_tp)
    spe
  } else {
    # return as numeric matrix
    stopifnot(nrow(input) == nrow(mat_tp))
    rownames(mat_tp) <- row_names
    mat_tp
  }
}
```

```{r}
if (is.null(random_effects_formula)) {
    
    ##########################
    # Fixed effects modeling #
    ##########################
    
    model_function <- function(formula,
                               data,
                               link,
                               optimizer,
                               na.action) {
      return(
        cplm::cpglm(
          formula = formula,
          data = data,
          link = link,
          optimizer = optimizer,
          na.action = na.action
        )
      )
      
    }
    
    summary_function <- function(fit) {
      cplm_out <-
        capture.output(cplm_summary <- cplm::summary(fit)$coefficients)
      para <- as.data.frame(cplm_summary)[-1,-3]
      para$base.model <- 'CPLM'
      para$tweedie.index <- round(fit$p, 3)
      para$name <- rownames(cplm_summary)[-1]
      return(para)
    }
    
  } else{
    
    ###########################
    # Random effects modeling #
    ###########################
    
    formula <-
      paste('. ~', paste(all.vars(formula)[-1], collapse = ' + '), '.', sep = ' + ')
    formula <- update(random_effects_formula, formula)
    
    model_function <- function(formula,
                               data,
                               link,
                               optimizer,
                               na.action) {
      return(
        glmmTMB::glmmTMB(
          formula = formula,
          data = data,
          family = glmmTMB::tweedie(link = link),
          ziformula = ~ 0,
          na.action = na.action
        )
      )
      
    }
    
    summary_function <- function(fit) {
      glmmTMB_summary <- coef(summary(fit))
      para <- as.data.frame(glmmTMB_summary$cond)[-1,-3]
      para$base.model <-
        ifelse(is.null(glmmTMB_summary$zi), 'CPLM', 'ZICP')
      para$tweedie.index <-
        round(unname(plogis(fit$fit$par["thetaf"]) + 1), 3)
      para$name <- rownames(glmmTMB_summary$cond)[-1]
      return(para)
    }
  }
  
  
  #######################################
  # Init cluster for parallel computing #
  #######################################
  
  cluster <- NULL
  if (cores > 1)
  {
    logging::loginfo("Creating cluster of %s R processes", cores)
    cluster <- parallel::makeCluster(cores)
    clusterExport(
      cluster,
      c(
        "features",
        "metadata",
        "formula",
        "link",
        "optimizer",
        "na.action",
        "model_function",
        "summary_function"
      ),
      envir = environment()
    )
  }
```

